2177d9248c089db83292daf0bed08d51
"use strict";
// Mock Next.js router
jest.mock("next/router", ()=>({
        useRouter () {
            return {
                route: "/",
                pathname: "/",
                query: "",
                asPath: "",
                push: jest.fn(),
                replace: jest.fn()
            };
        }
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_default(require("react"));
const _react1 = require("@testing-library/react");
const _userevent = /*#__PURE__*/ _interop_require_default(require("@testing-library/user-event"));
require("@testing-library/jest-dom");
const _UserSelector = /*#__PURE__*/ _interop_require_default(require("../components/User/UserSelector"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// Mock fetch globally
global.fetch = jest.fn();
describe("UserSelector Component", ()=>{
    let mockOnUserSelect;
    beforeEach(()=>{
        mockOnUserSelect = jest.fn();
        fetch.mockClear();
    });
    afterEach(()=>{
        jest.resetAllMocks();
    });
    const mockUsers = [
        {
            id: 1,
            username: "testuser1",
            created_at: "2023-01-01T00:00:00Z"
        },
        {
            id: 2,
            username: "testuser2",
            created_at: "2023-01-02T00:00:00Z"
        }
    ];
    describe("Loading State", ()=>{
        test("should show loading spinner whilst fetching users", ()=>{
            fetch.mockImplementation(()=>new Promise(()=>{})); // Never resolves
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UserSelector.default, {
                onUserSelect: mockOnUserSelect
            }));
            expect(_react1.screen.getByText("Loading users...")).toBeInTheDocument();
            expect(_react1.screen.getByText("Loading users...")).toBeInTheDocument();
        });
    });
    describe("User List Display", ()=>{
        test("should render list of existing users", async ()=>{
            fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>mockUsers
            });
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UserSelector.default, {
                onUserSelect: mockOnUserSelect
            }));
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByText("testuser1")).toBeInTheDocument();
                expect(_react1.screen.getByText("testuser2")).toBeInTheDocument();
            });
            expect(_react1.screen.getByText("Existing Profiles")).toBeInTheDocument();
        });
        test("should show creation date for each user", async ()=>{
            fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>mockUsers
            });
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UserSelector.default, {
                onUserSelect: mockOnUserSelect
            }));
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByText("Created 01/01/2023")).toBeInTheDocument();
                expect(_react1.screen.getByText("Created 02/01/2023")).toBeInTheDocument();
            });
        });
        test("should call onUserSelect when user is clicked", async ()=>{
            fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>mockUsers
            });
            const user = _userevent.default.setup();
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UserSelector.default, {
                onUserSelect: mockOnUserSelect
            }));
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByText("testuser1")).toBeInTheDocument();
            });
            await user.click(_react1.screen.getByText("testuser1"));
            expect(mockOnUserSelect).toHaveBeenCalledWith(mockUsers[0]);
        });
    });
    describe("Current User Display", ()=>{
        test("should show current user information when provided", async ()=>{
            fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>mockUsers
            });
            const currentUser = {
                id: 1,
                username: "currentuser"
            };
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UserSelector.default, {
                onUserSelect: mockOnUserSelect,
                currentUser: currentUser
            }));
            expect(_react1.screen.getByText("Currently logged in as:")).toBeInTheDocument();
            expect(_react1.screen.getByText("currentuser")).toBeInTheDocument();
            expect(_react1.screen.getByText("Switch User")).toBeInTheDocument();
        });
        test("should hide user selection when current user is set", async ()=>{
            fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>mockUsers
            });
            const currentUser = {
                id: 1,
                username: "currentuser"
            };
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UserSelector.default, {
                onUserSelect: mockOnUserSelect,
                currentUser: currentUser
            }));
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.queryByText("Existing Profiles")).not.toBeInTheDocument();
                expect(_react1.screen.queryByText("Create New Profile")).not.toBeInTheDocument();
            });
        });
        test("should call onUserSelect with null when switch user is clicked", async ()=>{
            fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>mockUsers
            });
            const currentUser = {
                id: 1,
                username: "currentuser"
            };
            const user = _userevent.default.setup();
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UserSelector.default, {
                onUserSelect: mockOnUserSelect,
                currentUser: currentUser
            }));
            await user.click(_react1.screen.getByText("Switch User"));
            expect(mockOnUserSelect).toHaveBeenCalledWith(null);
        });
    });
    describe("User Creation", ()=>{
        test("should show create new profile button initially", async ()=>{
            fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>mockUsers
            });
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UserSelector.default, {
                onUserSelect: mockOnUserSelect
            }));
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByText("+ Create New Profile")).toBeInTheDocument();
            });
        });
        test("should show form when create new profile is clicked", async ()=>{
            fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>mockUsers
            });
            const user = _userevent.default.setup();
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UserSelector.default, {
                onUserSelect: mockOnUserSelect
            }));
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByText("+ Create New Profile")).toBeInTheDocument();
            });
            await user.click(_react1.screen.getByText("+ Create New Profile"));
            expect(_react1.screen.getByLabelText("Username")).toBeInTheDocument();
            expect(_react1.screen.getByText("Create Profile")).toBeInTheDocument();
            expect(_react1.screen.getByText("Cancel")).toBeInTheDocument();
        });
        test("should create new user when form is submitted", async ()=>{
            fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>mockUsers
            }).mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        id: 3,
                        username: "newuser",
                        created_at: "2023-01-03T00:00:00Z"
                    })
            });
            const user = _userevent.default.setup();
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UserSelector.default, {
                onUserSelect: mockOnUserSelect
            }));
            // Wait for initial load and click create button
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByText("+ Create New Profile")).toBeInTheDocument();
            });
            await user.click(_react1.screen.getByText("+ Create New Profile"));
            // Fill in the form
            const usernameInput = _react1.screen.getByLabelText("Username");
            await user.type(usernameInput, "newuser");
            // Submit the form
            await user.click(_react1.screen.getByText("Create Profile"));
            // Check that the API was called correctly
            expect(fetch).toHaveBeenCalledWith("http://localhost:3001/api/users", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    username: "newuser"
                })
            });
            // Check that onUserSelect was called with the new user
            await (0, _react1.waitFor)(()=>{
                expect(mockOnUserSelect).toHaveBeenCalledWith({
                    id: 3,
                    username: "newuser",
                    created_at: "2023-01-03T00:00:00Z"
                });
            });
        });
        test("should disable create button when username is empty", async ()=>{
            fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>mockUsers
            });
            const user = _userevent.default.setup();
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UserSelector.default, {
                onUserSelect: mockOnUserSelect
            }));
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByText("+ Create New Profile")).toBeInTheDocument();
            });
            await user.click(_react1.screen.getByText("+ Create New Profile"));
            const createButton = _react1.screen.getByText("Create Profile");
            expect(createButton).toBeDisabled();
        });
        test("should show error when user creation fails", async ()=>{
            fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>mockUsers
            }).mockResolvedValueOnce({
                ok: false,
                json: async ()=>({
                        error: "Username already exists"
                    })
            });
            const user = _userevent.default.setup();
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UserSelector.default, {
                onUserSelect: mockOnUserSelect
            }));
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByText("+ Create New Profile")).toBeInTheDocument();
            });
            await user.click(_react1.screen.getByText("+ Create New Profile"));
            const usernameInput = _react1.screen.getByLabelText("Username");
            await user.type(usernameInput, "duplicateuser");
            await user.click(_react1.screen.getByText("Create Profile"));
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByText("Username already exists")).toBeInTheDocument();
            });
        });
        test("should cancel form when cancel button is clicked", async ()=>{
            fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>mockUsers
            });
            const user = _userevent.default.setup();
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UserSelector.default, {
                onUserSelect: mockOnUserSelect
            }));
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByText("+ Create New Profile")).toBeInTheDocument();
            });
            await user.click(_react1.screen.getByText("+ Create New Profile"));
            const usernameInput = _react1.screen.getByLabelText("Username");
            await user.type(usernameInput, "testinput");
            await user.click(_react1.screen.getByText("Cancel"));
            // Form should be hidden
            expect(_react1.screen.queryByLabelText("Username")).not.toBeInTheDocument();
            expect(_react1.screen.getByText("+ Create New Profile")).toBeInTheDocument();
        });
    });
    describe("Error Handling", ()=>{
        test("should show error when failing to fetch users", async ()=>{
            fetch.mockRejectedValueOnce(new Error("Network error"));
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UserSelector.default, {
                onUserSelect: mockOnUserSelect
            }));
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByText("Failed to load users")).toBeInTheDocument();
            });
        });
        test("should show error when API returns error status", async ()=>{
            fetch.mockResolvedValueOnce({
                ok: false,
                status: 500
            });
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UserSelector.default, {
                onUserSelect: mockOnUserSelect
            }));
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByText("Failed to load users")).toBeInTheDocument();
            });
        });
    });
    describe("Accessibility", ()=>{
        test("should have proper ARIA labels and roles", async ()=>{
            fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>mockUsers
            });
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UserSelector.default, {
                onUserSelect: mockOnUserSelect
            }));
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByText("+ Create New Profile")).toBeInTheDocument();
            });
            const user = _userevent.default.setup();
            await user.click(_react1.screen.getByText("+ Create New Profile"));
            const usernameInput = _react1.screen.getByLabelText("Username");
            expect(usernameInput).toHaveAttribute("id", "username");
            expect(usernameInput).toHaveAttribute("type", "text");
        });
        test("should be keyboard navigable", async ()=>{
            fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>mockUsers
            });
            const user = _userevent.default.setup();
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UserSelector.default, {
                onUserSelect: mockOnUserSelect
            }));
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByText("testuser1")).toBeInTheDocument();
            });
            // Tab to first user button
            await user.tab();
            const firstUserButton = _react1.screen.getByText("testuser1").closest("button");
            expect(firstUserButton).toHaveFocus();
            // Press Enter to select user
            await user.keyboard("{Enter}");
            expect(mockOnUserSelect).toHaveBeenCalledWith(mockUsers[0]);
        });
    });
    describe("Responsive Behaviour", ()=>{
        test("should handle empty users list gracefully", async ()=>{
            fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>[]
            });
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UserSelector.default, {
                onUserSelect: mockOnUserSelect
            }));
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByText("+ Create New Profile")).toBeInTheDocument();
            });
            // Should not show "Existing Profiles" section
            expect(_react1.screen.queryByText("Existing Profiles")).not.toBeInTheDocument();
            // Should still show create new profile option
            expect(_react1.screen.getByText("Create New Profile")).toBeInTheDocument();
        });
        test("should handle username with special characters", async ()=>{
            fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>[]
            }).mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        id: 1,
                        username: "user-with_special.chars",
                        created_at: "2023-01-01T00:00:00Z"
                    })
            });
            const user = _userevent.default.setup();
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UserSelector.default, {
                onUserSelect: mockOnUserSelect
            }));
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByText("+ Create New Profile")).toBeInTheDocument();
            });
            await user.click(_react1.screen.getByText("+ Create New Profile"));
            const usernameInput = _react1.screen.getByLabelText("Username");
            await user.type(usernameInput, "user-with_special.chars");
            await user.click(_react1.screen.getByText("Create Profile"));
            expect(fetch).toHaveBeenCalledWith("http://localhost:3001/api/users", expect.objectContaining({
                body: JSON.stringify({
                    username: "user-with_special.chars"
                })
            }));
        });
        test("should trim whitespace from username input", async ()=>{
            fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>[]
            }).mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        id: 1,
                        username: "trimmeduser",
                        created_at: "2023-01-01T00:00:00Z"
                    })
            });
            const user = _userevent.default.setup();
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UserSelector.default, {
                onUserSelect: mockOnUserSelect
            }));
            await (0, _react1.waitFor)(()=>{
                expect(_react1.screen.getByText("+ Create New Profile")).toBeInTheDocument();
            });
            await user.click(_react1.screen.getByText("+ Create New Profile"));
            const usernameInput = _react1.screen.getByLabelText("Username");
            await user.type(usernameInput, "  trimmeduser  ");
            await user.click(_react1.screen.getByText("Create Profile"));
            expect(fetch).toHaveBeenCalledWith("http://localhost:3001/api/users", expect.objectContaining({
                body: JSON.stringify({
                    username: "trimmeduser"
                })
            }));
        });
    });
    describe("Environment Configuration", ()=>{
        test("should use custom API URL from environment", async ()=>{
            const originalEnv = process.env.NEXT_PUBLIC_API_URL;
            process.env.NEXT_PUBLIC_API_URL = "https://custom-api.example.com";
            fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>mockUsers
            });
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UserSelector.default, {
                onUserSelect: mockOnUserSelect
            }));
            await (0, _react1.waitFor)(()=>{
                expect(fetch).toHaveBeenCalledWith("https://custom-api.example.com/api/users");
            });
            // Restore original environment
            process.env.NEXT_PUBLIC_API_URL = originalEnv;
        });
        test("should fall back to localhost when no environment URL is set", async ()=>{
            const originalEnv = process.env.NEXT_PUBLIC_API_URL;
            delete process.env.NEXT_PUBLIC_API_URL;
            fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>mockUsers
            });
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_UserSelector.default, {
                onUserSelect: mockOnUserSelect
            }));
            await (0, _react1.waitFor)(()=>{
                expect(fetch).toHaveBeenCalledWith("http://localhost:3001/api/users");
            });
            // Restore original environment
            process.env.NEXT_PUBLIC_API_URL = originalEnv;
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYW11ZWxsb3ZlL0RvY3VtZW50cy9HaXRIdWIvUGxhbnNld2Fsa2VyLXMtUHJpbWVyL2Zyb250ZW5kL3Rlc3RzL2NvbXBvbmVudHMudGVzdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgcmVuZGVyLCBzY3JlZW4sIGZpcmVFdmVudCwgd2FpdEZvciB9IGZyb20gJ0B0ZXN0aW5nLWxpYnJhcnkvcmVhY3QnO1xuaW1wb3J0IHVzZXJFdmVudCBmcm9tICdAdGVzdGluZy1saWJyYXJ5L3VzZXItZXZlbnQnO1xuaW1wb3J0ICdAdGVzdGluZy1saWJyYXJ5L2plc3QtZG9tJztcbmltcG9ydCBVc2VyU2VsZWN0b3IgZnJvbSAnLi4vY29tcG9uZW50cy9Vc2VyL1VzZXJTZWxlY3Rvcic7XG5cbi8vIE1vY2sgZmV0Y2ggZ2xvYmFsbHlcbmdsb2JhbC5mZXRjaCA9IGplc3QuZm4oKTtcblxuLy8gTW9jayBOZXh0LmpzIHJvdXRlclxuamVzdC5tb2NrKCduZXh0L3JvdXRlcicsICgpID0+ICh7XG4gIHVzZVJvdXRlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcm91dGU6ICcvJyxcbiAgICAgIHBhdGhuYW1lOiAnLycsXG4gICAgICBxdWVyeTogJycsXG4gICAgICBhc1BhdGg6ICcnLFxuICAgICAgcHVzaDogamVzdC5mbigpLFxuICAgICAgcmVwbGFjZTogamVzdC5mbigpLFxuICAgIH07XG4gIH0sXG59KSk7XG5cbmRlc2NyaWJlKCdVc2VyU2VsZWN0b3IgQ29tcG9uZW50JywgKCkgPT4ge1xuICBsZXQgbW9ja09uVXNlclNlbGVjdDtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBtb2NrT25Vc2VyU2VsZWN0ID0gamVzdC5mbigpO1xuICAgIGZldGNoLm1vY2tDbGVhcigpO1xuICB9KTtcblxuICBhZnRlckVhY2goKCkgPT4ge1xuICAgIGplc3QucmVzZXRBbGxNb2NrcygpO1xuICB9KTtcblxuICBjb25zdCBtb2NrVXNlcnMgPSBbXG4gICAge1xuICAgICAgaWQ6IDEsXG4gICAgICB1c2VybmFtZTogJ3Rlc3R1c2VyMScsXG4gICAgICBjcmVhdGVkX2F0OiAnMjAyMy0wMS0wMVQwMDowMDowMFonXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogMixcbiAgICAgIHVzZXJuYW1lOiAndGVzdHVzZXIyJyxcbiAgICAgIGNyZWF0ZWRfYXQ6ICcyMDIzLTAxLTAyVDAwOjAwOjAwWidcbiAgICB9XG4gIF07XG5cbiAgZGVzY3JpYmUoJ0xvYWRpbmcgU3RhdGUnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIHNob3cgbG9hZGluZyBzcGlubmVyIHdoaWxzdCBmZXRjaGluZyB1c2VycycsICgpID0+IHtcbiAgICAgIGZldGNoLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiBuZXcgUHJvbWlzZSgoKSA9PiB7fSkpOyAvLyBOZXZlciByZXNvbHZlc1xuXG4gICAgICByZW5kZXIoPFVzZXJTZWxlY3RvciBvblVzZXJTZWxlY3Q9e21vY2tPblVzZXJTZWxlY3R9IC8+KTtcblxuICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJ0xvYWRpbmcgdXNlcnMuLi4nKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCdMb2FkaW5nIHVzZXJzLi4uJykpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdVc2VyIExpc3QgRGlzcGxheScsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgcmVuZGVyIGxpc3Qgb2YgZXhpc3RpbmcgdXNlcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBmZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4gbW9ja1VzZXJzXG4gICAgICB9KTtcblxuICAgICAgcmVuZGVyKDxVc2VyU2VsZWN0b3Igb25Vc2VyU2VsZWN0PXttb2NrT25Vc2VyU2VsZWN0fSAvPik7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgndGVzdHVzZXIxJykpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCd0ZXN0dXNlcjInKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgnRXhpc3RpbmcgUHJvZmlsZXMnKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBzaG93IGNyZWF0aW9uIGRhdGUgZm9yIGVhY2ggdXNlcicsIGFzeW5jICgpID0+IHtcbiAgICAgIGZldGNoLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIG9rOiB0cnVlLFxuICAgICAgICBqc29uOiBhc3luYyAoKSA9PiBtb2NrVXNlcnNcbiAgICAgIH0pO1xuXG4gICAgICByZW5kZXIoPFVzZXJTZWxlY3RvciBvblVzZXJTZWxlY3Q9e21vY2tPblVzZXJTZWxlY3R9IC8+KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCdDcmVhdGVkIDAxLzAxLzIwMjMnKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJ0NyZWF0ZWQgMDIvMDEvMjAyMycpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgY2FsbCBvblVzZXJTZWxlY3Qgd2hlbiB1c2VyIGlzIGNsaWNrZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBmZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4gbW9ja1VzZXJzXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgdXNlciA9IHVzZXJFdmVudC5zZXR1cCgpO1xuICAgICAgcmVuZGVyKDxVc2VyU2VsZWN0b3Igb25Vc2VyU2VsZWN0PXttb2NrT25Vc2VyU2VsZWN0fSAvPik7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgndGVzdHVzZXIxJykpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgdXNlci5jbGljayhzY3JlZW4uZ2V0QnlUZXh0KCd0ZXN0dXNlcjEnKSk7XG5cbiAgICAgIGV4cGVjdChtb2NrT25Vc2VyU2VsZWN0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChtb2NrVXNlcnNbMF0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQ3VycmVudCBVc2VyIERpc3BsYXknLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIHNob3cgY3VycmVudCB1c2VyIGluZm9ybWF0aW9uIHdoZW4gcHJvdmlkZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBmZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4gbW9ja1VzZXJzXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgY3VycmVudFVzZXIgPSB7IGlkOiAxLCB1c2VybmFtZTogJ2N1cnJlbnR1c2VyJyB9O1xuICAgICAgcmVuZGVyKFxuICAgICAgICA8VXNlclNlbGVjdG9yXG4gICAgICAgICAgb25Vc2VyU2VsZWN0PXttb2NrT25Vc2VyU2VsZWN0fVxuICAgICAgICAgIGN1cnJlbnRVc2VyPXtjdXJyZW50VXNlcn1cbiAgICAgICAgLz5cbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCdDdXJyZW50bHkgbG9nZ2VkIGluIGFzOicpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJ2N1cnJlbnR1c2VyJykpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgnU3dpdGNoIFVzZXInKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoaWRlIHVzZXIgc2VsZWN0aW9uIHdoZW4gY3VycmVudCB1c2VyIGlzIHNldCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGZldGNoLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIG9rOiB0cnVlLFxuICAgICAgICBqc29uOiBhc3luYyAoKSA9PiBtb2NrVXNlcnNcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBjdXJyZW50VXNlciA9IHsgaWQ6IDEsIHVzZXJuYW1lOiAnY3VycmVudHVzZXInIH07XG4gICAgICByZW5kZXIoXG4gICAgICAgIDxVc2VyU2VsZWN0b3JcbiAgICAgICAgICBvblVzZXJTZWxlY3Q9e21vY2tPblVzZXJTZWxlY3R9XG4gICAgICAgICAgY3VycmVudFVzZXI9e2N1cnJlbnRVc2VyfVxuICAgICAgICAvPlxuICAgICAgKTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4ucXVlcnlCeVRleHQoJ0V4aXN0aW5nIFByb2ZpbGVzJykpLm5vdC50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgICBleHBlY3Qoc2NyZWVuLnF1ZXJ5QnlUZXh0KCdDcmVhdGUgTmV3IFByb2ZpbGUnKSkubm90LnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBjYWxsIG9uVXNlclNlbGVjdCB3aXRoIG51bGwgd2hlbiBzd2l0Y2ggdXNlciBpcyBjbGlja2VkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgZmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgb2s6IHRydWUsXG4gICAgICAgIGpzb246IGFzeW5jICgpID0+IG1vY2tVc2Vyc1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGN1cnJlbnRVc2VyID0geyBpZDogMSwgdXNlcm5hbWU6ICdjdXJyZW50dXNlcicgfTtcbiAgICAgIGNvbnN0IHVzZXIgPSB1c2VyRXZlbnQuc2V0dXAoKTtcblxuICAgICAgcmVuZGVyKFxuICAgICAgICA8VXNlclNlbGVjdG9yXG4gICAgICAgICAgb25Vc2VyU2VsZWN0PXttb2NrT25Vc2VyU2VsZWN0fVxuICAgICAgICAgIGN1cnJlbnRVc2VyPXtjdXJyZW50VXNlcn1cbiAgICAgICAgLz5cbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IHVzZXIuY2xpY2soc2NyZWVuLmdldEJ5VGV4dCgnU3dpdGNoIFVzZXInKSk7XG5cbiAgICAgIGV4cGVjdChtb2NrT25Vc2VyU2VsZWN0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChudWxsKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1VzZXIgQ3JlYXRpb24nLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIHNob3cgY3JlYXRlIG5ldyBwcm9maWxlIGJ1dHRvbiBpbml0aWFsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBmZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4gbW9ja1VzZXJzXG4gICAgICB9KTtcblxuICAgICAgcmVuZGVyKDxVc2VyU2VsZWN0b3Igb25Vc2VyU2VsZWN0PXttb2NrT25Vc2VyU2VsZWN0fSAvPik7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgnKyBDcmVhdGUgTmV3IFByb2ZpbGUnKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHNob3cgZm9ybSB3aGVuIGNyZWF0ZSBuZXcgcHJvZmlsZSBpcyBjbGlja2VkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgZmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgb2s6IHRydWUsXG4gICAgICAgIGpzb246IGFzeW5jICgpID0+IG1vY2tVc2Vyc1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHVzZXIgPSB1c2VyRXZlbnQuc2V0dXAoKTtcbiAgICAgIHJlbmRlcig8VXNlclNlbGVjdG9yIG9uVXNlclNlbGVjdD17bW9ja09uVXNlclNlbGVjdH0gLz4pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJysgQ3JlYXRlIE5ldyBQcm9maWxlJykpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgdXNlci5jbGljayhzY3JlZW4uZ2V0QnlUZXh0KCcrIENyZWF0ZSBOZXcgUHJvZmlsZScpKTtcblxuICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeUxhYmVsVGV4dCgnVXNlcm5hbWUnKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCdDcmVhdGUgUHJvZmlsZScpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJ0NhbmNlbCcpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGNyZWF0ZSBuZXcgdXNlciB3aGVuIGZvcm0gaXMgc3VibWl0dGVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgZmV0Y2hcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAganNvbjogYXN5bmMgKCkgPT4gbW9ja1VzZXJzXG4gICAgICAgIH0pXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7IGlkOiAzLCB1c2VybmFtZTogJ25ld3VzZXInLCBjcmVhdGVkX2F0OiAnMjAyMy0wMS0wM1QwMDowMDowMFonIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICBjb25zdCB1c2VyID0gdXNlckV2ZW50LnNldHVwKCk7XG4gICAgICByZW5kZXIoPFVzZXJTZWxlY3RvciBvblVzZXJTZWxlY3Q9e21vY2tPblVzZXJTZWxlY3R9IC8+KTtcblxuICAgICAgLy8gV2FpdCBmb3IgaW5pdGlhbCBsb2FkIGFuZCBjbGljayBjcmVhdGUgYnV0dG9uXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJysgQ3JlYXRlIE5ldyBQcm9maWxlJykpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgdXNlci5jbGljayhzY3JlZW4uZ2V0QnlUZXh0KCcrIENyZWF0ZSBOZXcgUHJvZmlsZScpKTtcblxuICAgICAgLy8gRmlsbCBpbiB0aGUgZm9ybVxuICAgICAgY29uc3QgdXNlcm5hbWVJbnB1dCA9IHNjcmVlbi5nZXRCeUxhYmVsVGV4dCgnVXNlcm5hbWUnKTtcbiAgICAgIGF3YWl0IHVzZXIudHlwZSh1c2VybmFtZUlucHV0LCAnbmV3dXNlcicpO1xuXG4gICAgICAvLyBTdWJtaXQgdGhlIGZvcm1cbiAgICAgIGF3YWl0IHVzZXIuY2xpY2soc2NyZWVuLmdldEJ5VGV4dCgnQ3JlYXRlIFByb2ZpbGUnKSk7XG5cbiAgICAgIC8vIENoZWNrIHRoYXQgdGhlIEFQSSB3YXMgY2FsbGVkIGNvcnJlY3RseVxuICAgICAgZXhwZWN0KGZldGNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMS9hcGkvdXNlcnMnLFxuICAgICAgICB7XG4gICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgdXNlcm5hbWU6ICduZXd1c2VyJyB9KVxuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICAvLyBDaGVjayB0aGF0IG9uVXNlclNlbGVjdCB3YXMgY2FsbGVkIHdpdGggdGhlIG5ldyB1c2VyXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KG1vY2tPblVzZXJTZWxlY3QpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcbiAgICAgICAgICBpZDogMyxcbiAgICAgICAgICB1c2VybmFtZTogJ25ld3VzZXInLFxuICAgICAgICAgIGNyZWF0ZWRfYXQ6ICcyMDIzLTAxLTAzVDAwOjAwOjAwWidcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBkaXNhYmxlIGNyZWF0ZSBidXR0b24gd2hlbiB1c2VybmFtZSBpcyBlbXB0eScsIGFzeW5jICgpID0+IHtcbiAgICAgIGZldGNoLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIG9rOiB0cnVlLFxuICAgICAgICBqc29uOiBhc3luYyAoKSA9PiBtb2NrVXNlcnNcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB1c2VyID0gdXNlckV2ZW50LnNldHVwKCk7XG4gICAgICByZW5kZXIoPFVzZXJTZWxlY3RvciBvblVzZXJTZWxlY3Q9e21vY2tPblVzZXJTZWxlY3R9IC8+KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCcrIENyZWF0ZSBOZXcgUHJvZmlsZScpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IHVzZXIuY2xpY2soc2NyZWVuLmdldEJ5VGV4dCgnKyBDcmVhdGUgTmV3IFByb2ZpbGUnKSk7XG5cbiAgICAgIGNvbnN0IGNyZWF0ZUJ1dHRvbiA9IHNjcmVlbi5nZXRCeVRleHQoJ0NyZWF0ZSBQcm9maWxlJyk7XG4gICAgICBleHBlY3QoY3JlYXRlQnV0dG9uKS50b0JlRGlzYWJsZWQoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBzaG93IGVycm9yIHdoZW4gdXNlciBjcmVhdGlvbiBmYWlscycsIGFzeW5jICgpID0+IHtcbiAgICAgIGZldGNoXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIGpzb246IGFzeW5jICgpID0+IG1vY2tVc2Vyc1xuICAgICAgICB9KVxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogZmFsc2UsXG4gICAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHsgZXJyb3I6ICdVc2VybmFtZSBhbHJlYWR5IGV4aXN0cycgfSlcbiAgICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHVzZXIgPSB1c2VyRXZlbnQuc2V0dXAoKTtcbiAgICAgIHJlbmRlcig8VXNlclNlbGVjdG9yIG9uVXNlclNlbGVjdD17bW9ja09uVXNlclNlbGVjdH0gLz4pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJysgQ3JlYXRlIE5ldyBQcm9maWxlJykpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgdXNlci5jbGljayhzY3JlZW4uZ2V0QnlUZXh0KCcrIENyZWF0ZSBOZXcgUHJvZmlsZScpKTtcblxuICAgICAgY29uc3QgdXNlcm5hbWVJbnB1dCA9IHNjcmVlbi5nZXRCeUxhYmVsVGV4dCgnVXNlcm5hbWUnKTtcbiAgICAgIGF3YWl0IHVzZXIudHlwZSh1c2VybmFtZUlucHV0LCAnZHVwbGljYXRldXNlcicpO1xuXG4gICAgICBhd2FpdCB1c2VyLmNsaWNrKHNjcmVlbi5nZXRCeVRleHQoJ0NyZWF0ZSBQcm9maWxlJykpO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJ1VzZXJuYW1lIGFscmVhZHkgZXhpc3RzJykpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBjYW5jZWwgZm9ybSB3aGVuIGNhbmNlbCBidXR0b24gaXMgY2xpY2tlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGZldGNoLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIG9rOiB0cnVlLFxuICAgICAgICBqc29uOiBhc3luYyAoKSA9PiBtb2NrVXNlcnNcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB1c2VyID0gdXNlckV2ZW50LnNldHVwKCk7XG4gICAgICByZW5kZXIoPFVzZXJTZWxlY3RvciBvblVzZXJTZWxlY3Q9e21vY2tPblVzZXJTZWxlY3R9IC8+KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCcrIENyZWF0ZSBOZXcgUHJvZmlsZScpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IHVzZXIuY2xpY2soc2NyZWVuLmdldEJ5VGV4dCgnKyBDcmVhdGUgTmV3IFByb2ZpbGUnKSk7XG5cbiAgICAgIGNvbnN0IHVzZXJuYW1lSW5wdXQgPSBzY3JlZW4uZ2V0QnlMYWJlbFRleHQoJ1VzZXJuYW1lJyk7XG4gICAgICBhd2FpdCB1c2VyLnR5cGUodXNlcm5hbWVJbnB1dCwgJ3Rlc3RpbnB1dCcpO1xuXG4gICAgICBhd2FpdCB1c2VyLmNsaWNrKHNjcmVlbi5nZXRCeVRleHQoJ0NhbmNlbCcpKTtcblxuICAgICAgLy8gRm9ybSBzaG91bGQgYmUgaGlkZGVuXG4gICAgICBleHBlY3Qoc2NyZWVuLnF1ZXJ5QnlMYWJlbFRleHQoJ1VzZXJuYW1lJykpLm5vdC50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJysgQ3JlYXRlIE5ldyBQcm9maWxlJykpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdFcnJvciBIYW5kbGluZycsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgc2hvdyBlcnJvciB3aGVuIGZhaWxpbmcgdG8gZmV0Y2ggdXNlcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBmZXRjaC5tb2NrUmVqZWN0ZWRWYWx1ZU9uY2UobmV3IEVycm9yKCdOZXR3b3JrIGVycm9yJykpO1xuXG4gICAgICByZW5kZXIoPFVzZXJTZWxlY3RvciBvblVzZXJTZWxlY3Q9e21vY2tPblVzZXJTZWxlY3R9IC8+KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCdGYWlsZWQgdG8gbG9hZCB1c2VycycpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgc2hvdyBlcnJvciB3aGVuIEFQSSByZXR1cm5zIGVycm9yIHN0YXR1cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGZldGNoLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgc3RhdHVzOiA1MDBcbiAgICAgIH0pO1xuXG4gICAgICByZW5kZXIoPFVzZXJTZWxlY3RvciBvblVzZXJTZWxlY3Q9e21vY2tPblVzZXJTZWxlY3R9IC8+KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCdGYWlsZWQgdG8gbG9hZCB1c2VycycpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdBY2Nlc3NpYmlsaXR5JywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBoYXZlIHByb3BlciBBUklBIGxhYmVscyBhbmQgcm9sZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBmZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4gbW9ja1VzZXJzXG4gICAgICB9KTtcblxuICAgICAgcmVuZGVyKDxVc2VyU2VsZWN0b3Igb25Vc2VyU2VsZWN0PXttb2NrT25Vc2VyU2VsZWN0fSAvPik7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgnKyBDcmVhdGUgTmV3IFByb2ZpbGUnKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB1c2VyID0gdXNlckV2ZW50LnNldHVwKCk7XG4gICAgICBhd2FpdCB1c2VyLmNsaWNrKHNjcmVlbi5nZXRCeVRleHQoJysgQ3JlYXRlIE5ldyBQcm9maWxlJykpO1xuXG4gICAgICBjb25zdCB1c2VybmFtZUlucHV0ID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KCdVc2VybmFtZScpO1xuICAgICAgZXhwZWN0KHVzZXJuYW1lSW5wdXQpLnRvSGF2ZUF0dHJpYnV0ZSgnaWQnLCAndXNlcm5hbWUnKTtcbiAgICAgIGV4cGVjdCh1c2VybmFtZUlucHV0KS50b0hhdmVBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dCcpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGJlIGtleWJvYXJkIG5hdmlnYWJsZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGZldGNoLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIG9rOiB0cnVlLFxuICAgICAgICBqc29uOiBhc3luYyAoKSA9PiBtb2NrVXNlcnNcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB1c2VyID0gdXNlckV2ZW50LnNldHVwKCk7XG4gICAgICByZW5kZXIoPFVzZXJTZWxlY3RvciBvblVzZXJTZWxlY3Q9e21vY2tPblVzZXJTZWxlY3R9IC8+KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCd0ZXN0dXNlcjEnKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBUYWIgdG8gZmlyc3QgdXNlciBidXR0b25cbiAgICAgIGF3YWl0IHVzZXIudGFiKCk7XG4gICAgICBjb25zdCBmaXJzdFVzZXJCdXR0b24gPSBzY3JlZW4uZ2V0QnlUZXh0KCd0ZXN0dXNlcjEnKS5jbG9zZXN0KCdidXR0b24nKTtcbiAgICAgIGV4cGVjdChmaXJzdFVzZXJCdXR0b24pLnRvSGF2ZUZvY3VzKCk7XG5cbiAgICAgIC8vIFByZXNzIEVudGVyIHRvIHNlbGVjdCB1c2VyXG4gICAgICBhd2FpdCB1c2VyLmtleWJvYXJkKCd7RW50ZXJ9Jyk7XG4gICAgICBleHBlY3QobW9ja09uVXNlclNlbGVjdCkudG9IYXZlQmVlbkNhbGxlZFdpdGgobW9ja1VzZXJzWzBdKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1Jlc3BvbnNpdmUgQmVoYXZpb3VyJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgZW1wdHkgdXNlcnMgbGlzdCBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgZmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgb2s6IHRydWUsXG4gICAgICAgIGpzb246IGFzeW5jICgpID0+IFtdXG4gICAgICB9KTtcblxuICAgICAgcmVuZGVyKDxVc2VyU2VsZWN0b3Igb25Vc2VyU2VsZWN0PXttb2NrT25Vc2VyU2VsZWN0fSAvPik7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgnKyBDcmVhdGUgTmV3IFByb2ZpbGUnKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTaG91bGQgbm90IHNob3cgXCJFeGlzdGluZyBQcm9maWxlc1wiIHNlY3Rpb25cbiAgICAgIGV4cGVjdChzY3JlZW4ucXVlcnlCeVRleHQoJ0V4aXN0aW5nIFByb2ZpbGVzJykpLm5vdC50b0JlSW5UaGVEb2N1bWVudCgpO1xuXG4gICAgICAvLyBTaG91bGQgc3RpbGwgc2hvdyBjcmVhdGUgbmV3IHByb2ZpbGUgb3B0aW9uXG4gICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgnQ3JlYXRlIE5ldyBQcm9maWxlJykpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIHVzZXJuYW1lIHdpdGggc3BlY2lhbCBjaGFyYWN0ZXJzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgZmV0Y2hcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAganNvbjogYXN5bmMgKCkgPT4gW11cbiAgICAgICAgfSlcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHtcbiAgICAgICAgICAgIGlkOiAxLFxuICAgICAgICAgICAgdXNlcm5hbWU6ICd1c2VyLXdpdGhfc3BlY2lhbC5jaGFycycsXG4gICAgICAgICAgICBjcmVhdGVkX2F0OiAnMjAyMy0wMS0wMVQwMDowMDowMFonXG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHVzZXIgPSB1c2VyRXZlbnQuc2V0dXAoKTtcbiAgICAgIHJlbmRlcig8VXNlclNlbGVjdG9yIG9uVXNlclNlbGVjdD17bW9ja09uVXNlclNlbGVjdH0gLz4pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJysgQ3JlYXRlIE5ldyBQcm9maWxlJykpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgdXNlci5jbGljayhzY3JlZW4uZ2V0QnlUZXh0KCcrIENyZWF0ZSBOZXcgUHJvZmlsZScpKTtcblxuICAgICAgY29uc3QgdXNlcm5hbWVJbnB1dCA9IHNjcmVlbi5nZXRCeUxhYmVsVGV4dCgnVXNlcm5hbWUnKTtcbiAgICAgIGF3YWl0IHVzZXIudHlwZSh1c2VybmFtZUlucHV0LCAndXNlci13aXRoX3NwZWNpYWwuY2hhcnMnKTtcblxuICAgICAgYXdhaXQgdXNlci5jbGljayhzY3JlZW4uZ2V0QnlUZXh0KCdDcmVhdGUgUHJvZmlsZScpKTtcblxuICAgICAgZXhwZWN0KGZldGNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMS9hcGkvdXNlcnMnLFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyB1c2VybmFtZTogJ3VzZXItd2l0aF9zcGVjaWFsLmNoYXJzJyB9KVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCB0cmltIHdoaXRlc3BhY2UgZnJvbSB1c2VybmFtZSBpbnB1dCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGZldGNoXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIGpzb246IGFzeW5jICgpID0+IFtdXG4gICAgICAgIH0pXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7XG4gICAgICAgICAgICBpZDogMSxcbiAgICAgICAgICAgIHVzZXJuYW1lOiAndHJpbW1lZHVzZXInLFxuICAgICAgICAgICAgY3JlYXRlZF9hdDogJzIwMjMtMDEtMDFUMDA6MDA6MDBaJ1xuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICBjb25zdCB1c2VyID0gdXNlckV2ZW50LnNldHVwKCk7XG4gICAgICByZW5kZXIoPFVzZXJTZWxlY3RvciBvblVzZXJTZWxlY3Q9e21vY2tPblVzZXJTZWxlY3R9IC8+KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCcrIENyZWF0ZSBOZXcgUHJvZmlsZScpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IHVzZXIuY2xpY2soc2NyZWVuLmdldEJ5VGV4dCgnKyBDcmVhdGUgTmV3IFByb2ZpbGUnKSk7XG5cbiAgICAgIGNvbnN0IHVzZXJuYW1lSW5wdXQgPSBzY3JlZW4uZ2V0QnlMYWJlbFRleHQoJ1VzZXJuYW1lJyk7XG4gICAgICBhd2FpdCB1c2VyLnR5cGUodXNlcm5hbWVJbnB1dCwgJyAgdHJpbW1lZHVzZXIgICcpO1xuXG4gICAgICBhd2FpdCB1c2VyLmNsaWNrKHNjcmVlbi5nZXRCeVRleHQoJ0NyZWF0ZSBQcm9maWxlJykpO1xuXG4gICAgICBleHBlY3QoZmV0Y2gpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAnaHR0cDovL2xvY2FsaG9zdDozMDAxL2FwaS91c2VycycsXG4gICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHVzZXJuYW1lOiAndHJpbW1lZHVzZXInIH0pXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnRW52aXJvbm1lbnQgQ29uZmlndXJhdGlvbicsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgdXNlIGN1c3RvbSBBUEkgVVJMIGZyb20gZW52aXJvbm1lbnQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvcmlnaW5hbEVudiA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkw7XG4gICAgICBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMID0gJ2h0dHBzOi8vY3VzdG9tLWFwaS5leGFtcGxlLmNvbSc7XG5cbiAgICAgIGZldGNoLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIG9rOiB0cnVlLFxuICAgICAgICBqc29uOiBhc3luYyAoKSA9PiBtb2NrVXNlcnNcbiAgICAgIH0pO1xuXG4gICAgICByZW5kZXIoPFVzZXJTZWxlY3RvciBvblVzZXJTZWxlY3Q9e21vY2tPblVzZXJTZWxlY3R9IC8+KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChmZXRjaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ2h0dHBzOi8vY3VzdG9tLWFwaS5leGFtcGxlLmNvbS9hcGkvdXNlcnMnKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBSZXN0b3JlIG9yaWdpbmFsIGVudmlyb25tZW50XG4gICAgICBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMID0gb3JpZ2luYWxFbnY7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgZmFsbCBiYWNrIHRvIGxvY2FsaG9zdCB3aGVuIG5vIGVudmlyb25tZW50IFVSTCBpcyBzZXQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvcmlnaW5hbEVudiA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkw7XG4gICAgICBkZWxldGUgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTDtcblxuICAgICAgZmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgb2s6IHRydWUsXG4gICAgICAgIGpzb246IGFzeW5jICgpID0+IG1vY2tVc2Vyc1xuICAgICAgfSk7XG5cbiAgICAgIHJlbmRlcig8VXNlclNlbGVjdG9yIG9uVXNlclNlbGVjdD17bW9ja09uVXNlclNlbGVjdH0gLz4pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KGZldGNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnaHR0cDovL2xvY2FsaG9zdDozMDAxL2FwaS91c2VycycpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFJlc3RvcmUgb3JpZ2luYWwgZW52aXJvbm1lbnRcbiAgICAgIHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkwgPSBvcmlnaW5hbEVudjtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsInVzZVJvdXRlciIsInJvdXRlIiwicGF0aG5hbWUiLCJxdWVyeSIsImFzUGF0aCIsInB1c2giLCJmbiIsInJlcGxhY2UiLCJnbG9iYWwiLCJmZXRjaCIsImRlc2NyaWJlIiwibW9ja09uVXNlclNlbGVjdCIsImJlZm9yZUVhY2giLCJtb2NrQ2xlYXIiLCJhZnRlckVhY2giLCJyZXNldEFsbE1vY2tzIiwibW9ja1VzZXJzIiwiaWQiLCJ1c2VybmFtZSIsImNyZWF0ZWRfYXQiLCJ0ZXN0IiwibW9ja0ltcGxlbWVudGF0aW9uIiwiUHJvbWlzZSIsInJlbmRlciIsIlVzZXJTZWxlY3RvciIsIm9uVXNlclNlbGVjdCIsImV4cGVjdCIsInNjcmVlbiIsImdldEJ5VGV4dCIsInRvQmVJblRoZURvY3VtZW50IiwibW9ja1Jlc29sdmVkVmFsdWVPbmNlIiwib2siLCJqc29uIiwid2FpdEZvciIsInVzZXIiLCJ1c2VyRXZlbnQiLCJzZXR1cCIsImNsaWNrIiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJjdXJyZW50VXNlciIsInF1ZXJ5QnlUZXh0Iiwibm90IiwiZ2V0QnlMYWJlbFRleHQiLCJ1c2VybmFtZUlucHV0IiwidHlwZSIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImNyZWF0ZUJ1dHRvbiIsInRvQmVEaXNhYmxlZCIsImVycm9yIiwicXVlcnlCeUxhYmVsVGV4dCIsIm1vY2tSZWplY3RlZFZhbHVlT25jZSIsIkVycm9yIiwic3RhdHVzIiwidG9IYXZlQXR0cmlidXRlIiwidGFiIiwiZmlyc3RVc2VyQnV0dG9uIiwiY2xvc2VzdCIsInRvSGF2ZUZvY3VzIiwia2V5Ym9hcmQiLCJvYmplY3RDb250YWluaW5nIiwib3JpZ2luYWxFbnYiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX1VSTCJdLCJtYXBwaW5ncyI6IjtBQVNBLHNCQUFzQjtBQUN0QkEsS0FBS0MsSUFBSSxDQUFDLGVBQWUsSUFBTyxDQUFBO1FBQzlCQztZQUNFLE9BQU87Z0JBQ0xDLE9BQU87Z0JBQ1BDLFVBQVU7Z0JBQ1ZDLE9BQU87Z0JBQ1BDLFFBQVE7Z0JBQ1JDLE1BQU1QLEtBQUtRLEVBQUU7Z0JBQ2JDLFNBQVNULEtBQUtRLEVBQUU7WUFDbEI7UUFDRjtJQUNGLENBQUE7Ozs7OzhEQXJCa0I7d0JBQ2lDO2tFQUM3QjtRQUNmO3FFQUNrQjs7Ozs7O0FBRXpCLHNCQUFzQjtBQUN0QkUsT0FBT0MsS0FBSyxHQUFHWCxLQUFLUSxFQUFFO0FBZ0J0QkksU0FBUywwQkFBMEI7SUFDakMsSUFBSUM7SUFFSkMsV0FBVztRQUNURCxtQkFBbUJiLEtBQUtRLEVBQUU7UUFDMUJHLE1BQU1JLFNBQVM7SUFDakI7SUFFQUMsVUFBVTtRQUNSaEIsS0FBS2lCLGFBQWE7SUFDcEI7SUFFQSxNQUFNQyxZQUFZO1FBQ2hCO1lBQ0VDLElBQUk7WUFDSkMsVUFBVTtZQUNWQyxZQUFZO1FBQ2Q7UUFDQTtZQUNFRixJQUFJO1lBQ0pDLFVBQVU7WUFDVkMsWUFBWTtRQUNkO0tBQ0Q7SUFFRFQsU0FBUyxpQkFBaUI7UUFDeEJVLEtBQUsscURBQXFEO1lBQ3hEWCxNQUFNWSxrQkFBa0IsQ0FBQyxJQUFNLElBQUlDLFFBQVEsS0FBTyxLQUFLLGlCQUFpQjtZQUV4RUMsSUFBQUEsY0FBTSxnQkFBQyxxQkFBQ0MscUJBQVk7Z0JBQUNDLGNBQWNkOztZQUVuQ2UsT0FBT0MsY0FBTSxDQUFDQyxTQUFTLENBQUMscUJBQXFCQyxpQkFBaUI7WUFDOURILE9BQU9DLGNBQU0sQ0FBQ0MsU0FBUyxDQUFDLHFCQUFxQkMsaUJBQWlCO1FBQ2hFO0lBQ0Y7SUFFQW5CLFNBQVMscUJBQXFCO1FBQzVCVSxLQUFLLHdDQUF3QztZQUMzQ1gsTUFBTXFCLHFCQUFxQixDQUFDO2dCQUMxQkMsSUFBSTtnQkFDSkMsTUFBTSxVQUFZaEI7WUFDcEI7WUFFQU8sSUFBQUEsY0FBTSxnQkFBQyxxQkFBQ0MscUJBQVk7Z0JBQUNDLGNBQWNkOztZQUVuQyxNQUFNc0IsSUFBQUEsZUFBTyxFQUFDO2dCQUNaUCxPQUFPQyxjQUFNLENBQUNDLFNBQVMsQ0FBQyxjQUFjQyxpQkFBaUI7Z0JBQ3ZESCxPQUFPQyxjQUFNLENBQUNDLFNBQVMsQ0FBQyxjQUFjQyxpQkFBaUI7WUFDekQ7WUFFQUgsT0FBT0MsY0FBTSxDQUFDQyxTQUFTLENBQUMsc0JBQXNCQyxpQkFBaUI7UUFDakU7UUFFQVQsS0FBSywyQ0FBMkM7WUFDOUNYLE1BQU1xQixxQkFBcUIsQ0FBQztnQkFDMUJDLElBQUk7Z0JBQ0pDLE1BQU0sVUFBWWhCO1lBQ3BCO1lBRUFPLElBQUFBLGNBQU0sZ0JBQUMscUJBQUNDLHFCQUFZO2dCQUFDQyxjQUFjZDs7WUFFbkMsTUFBTXNCLElBQUFBLGVBQU8sRUFBQztnQkFDWlAsT0FBT0MsY0FBTSxDQUFDQyxTQUFTLENBQUMsdUJBQXVCQyxpQkFBaUI7Z0JBQ2hFSCxPQUFPQyxjQUFNLENBQUNDLFNBQVMsQ0FBQyx1QkFBdUJDLGlCQUFpQjtZQUNsRTtRQUNGO1FBRUFULEtBQUssaURBQWlEO1lBQ3BEWCxNQUFNcUIscUJBQXFCLENBQUM7Z0JBQzFCQyxJQUFJO2dCQUNKQyxNQUFNLFVBQVloQjtZQUNwQjtZQUVBLE1BQU1rQixPQUFPQyxrQkFBUyxDQUFDQyxLQUFLO1lBQzVCYixJQUFBQSxjQUFNLGdCQUFDLHFCQUFDQyxxQkFBWTtnQkFBQ0MsY0FBY2Q7O1lBRW5DLE1BQU1zQixJQUFBQSxlQUFPLEVBQUM7Z0JBQ1pQLE9BQU9DLGNBQU0sQ0FBQ0MsU0FBUyxDQUFDLGNBQWNDLGlCQUFpQjtZQUN6RDtZQUVBLE1BQU1LLEtBQUtHLEtBQUssQ0FBQ1YsY0FBTSxDQUFDQyxTQUFTLENBQUM7WUFFbENGLE9BQU9mLGtCQUFrQjJCLG9CQUFvQixDQUFDdEIsU0FBUyxDQUFDLEVBQUU7UUFDNUQ7SUFDRjtJQUVBTixTQUFTLHdCQUF3QjtRQUMvQlUsS0FBSyxzREFBc0Q7WUFDekRYLE1BQU1xQixxQkFBcUIsQ0FBQztnQkFDMUJDLElBQUk7Z0JBQ0pDLE1BQU0sVUFBWWhCO1lBQ3BCO1lBRUEsTUFBTXVCLGNBQWM7Z0JBQUV0QixJQUFJO2dCQUFHQyxVQUFVO1lBQWM7WUFDckRLLElBQUFBLGNBQU0sZ0JBQ0oscUJBQUNDLHFCQUFZO2dCQUNYQyxjQUFjZDtnQkFDZDRCLGFBQWFBOztZQUlqQmIsT0FBT0MsY0FBTSxDQUFDQyxTQUFTLENBQUMsNEJBQTRCQyxpQkFBaUI7WUFDckVILE9BQU9DLGNBQU0sQ0FBQ0MsU0FBUyxDQUFDLGdCQUFnQkMsaUJBQWlCO1lBQ3pESCxPQUFPQyxjQUFNLENBQUNDLFNBQVMsQ0FBQyxnQkFBZ0JDLGlCQUFpQjtRQUMzRDtRQUVBVCxLQUFLLHVEQUF1RDtZQUMxRFgsTUFBTXFCLHFCQUFxQixDQUFDO2dCQUMxQkMsSUFBSTtnQkFDSkMsTUFBTSxVQUFZaEI7WUFDcEI7WUFFQSxNQUFNdUIsY0FBYztnQkFBRXRCLElBQUk7Z0JBQUdDLFVBQVU7WUFBYztZQUNyREssSUFBQUEsY0FBTSxnQkFDSixxQkFBQ0MscUJBQVk7Z0JBQ1hDLGNBQWNkO2dCQUNkNEIsYUFBYUE7O1lBSWpCLE1BQU1OLElBQUFBLGVBQU8sRUFBQztnQkFDWlAsT0FBT0MsY0FBTSxDQUFDYSxXQUFXLENBQUMsc0JBQXNCQyxHQUFHLENBQUNaLGlCQUFpQjtnQkFDckVILE9BQU9DLGNBQU0sQ0FBQ2EsV0FBVyxDQUFDLHVCQUF1QkMsR0FBRyxDQUFDWixpQkFBaUI7WUFDeEU7UUFDRjtRQUVBVCxLQUFLLGtFQUFrRTtZQUNyRVgsTUFBTXFCLHFCQUFxQixDQUFDO2dCQUMxQkMsSUFBSTtnQkFDSkMsTUFBTSxVQUFZaEI7WUFDcEI7WUFFQSxNQUFNdUIsY0FBYztnQkFBRXRCLElBQUk7Z0JBQUdDLFVBQVU7WUFBYztZQUNyRCxNQUFNZ0IsT0FBT0Msa0JBQVMsQ0FBQ0MsS0FBSztZQUU1QmIsSUFBQUEsY0FBTSxnQkFDSixxQkFBQ0MscUJBQVk7Z0JBQ1hDLGNBQWNkO2dCQUNkNEIsYUFBYUE7O1lBSWpCLE1BQU1MLEtBQUtHLEtBQUssQ0FBQ1YsY0FBTSxDQUFDQyxTQUFTLENBQUM7WUFFbENGLE9BQU9mLGtCQUFrQjJCLG9CQUFvQixDQUFDO1FBQ2hEO0lBQ0Y7SUFFQTVCLFNBQVMsaUJBQWlCO1FBQ3hCVSxLQUFLLG1EQUFtRDtZQUN0RFgsTUFBTXFCLHFCQUFxQixDQUFDO2dCQUMxQkMsSUFBSTtnQkFDSkMsTUFBTSxVQUFZaEI7WUFDcEI7WUFFQU8sSUFBQUEsY0FBTSxnQkFBQyxxQkFBQ0MscUJBQVk7Z0JBQUNDLGNBQWNkOztZQUVuQyxNQUFNc0IsSUFBQUEsZUFBTyxFQUFDO2dCQUNaUCxPQUFPQyxjQUFNLENBQUNDLFNBQVMsQ0FBQyx5QkFBeUJDLGlCQUFpQjtZQUNwRTtRQUNGO1FBRUFULEtBQUssdURBQXVEO1lBQzFEWCxNQUFNcUIscUJBQXFCLENBQUM7Z0JBQzFCQyxJQUFJO2dCQUNKQyxNQUFNLFVBQVloQjtZQUNwQjtZQUVBLE1BQU1rQixPQUFPQyxrQkFBUyxDQUFDQyxLQUFLO1lBQzVCYixJQUFBQSxjQUFNLGdCQUFDLHFCQUFDQyxxQkFBWTtnQkFBQ0MsY0FBY2Q7O1lBRW5DLE1BQU1zQixJQUFBQSxlQUFPLEVBQUM7Z0JBQ1pQLE9BQU9DLGNBQU0sQ0FBQ0MsU0FBUyxDQUFDLHlCQUF5QkMsaUJBQWlCO1lBQ3BFO1lBRUEsTUFBTUssS0FBS0csS0FBSyxDQUFDVixjQUFNLENBQUNDLFNBQVMsQ0FBQztZQUVsQ0YsT0FBT0MsY0FBTSxDQUFDZSxjQUFjLENBQUMsYUFBYWIsaUJBQWlCO1lBQzNESCxPQUFPQyxjQUFNLENBQUNDLFNBQVMsQ0FBQyxtQkFBbUJDLGlCQUFpQjtZQUM1REgsT0FBT0MsY0FBTSxDQUFDQyxTQUFTLENBQUMsV0FBV0MsaUJBQWlCO1FBQ3REO1FBRUFULEtBQUssaURBQWlEO1lBQ3BEWCxNQUNHcUIscUJBQXFCLENBQUM7Z0JBQ3JCQyxJQUFJO2dCQUNKQyxNQUFNLFVBQVloQjtZQUNwQixHQUNDYyxxQkFBcUIsQ0FBQztnQkFDckJDLElBQUk7Z0JBQ0pDLE1BQU0sVUFBYSxDQUFBO3dCQUFFZixJQUFJO3dCQUFHQyxVQUFVO3dCQUFXQyxZQUFZO29CQUF1QixDQUFBO1lBQ3RGO1lBRUYsTUFBTWUsT0FBT0Msa0JBQVMsQ0FBQ0MsS0FBSztZQUM1QmIsSUFBQUEsY0FBTSxnQkFBQyxxQkFBQ0MscUJBQVk7Z0JBQUNDLGNBQWNkOztZQUVuQyxnREFBZ0Q7WUFDaEQsTUFBTXNCLElBQUFBLGVBQU8sRUFBQztnQkFDWlAsT0FBT0MsY0FBTSxDQUFDQyxTQUFTLENBQUMseUJBQXlCQyxpQkFBaUI7WUFDcEU7WUFFQSxNQUFNSyxLQUFLRyxLQUFLLENBQUNWLGNBQU0sQ0FBQ0MsU0FBUyxDQUFDO1lBRWxDLG1CQUFtQjtZQUNuQixNQUFNZSxnQkFBZ0JoQixjQUFNLENBQUNlLGNBQWMsQ0FBQztZQUM1QyxNQUFNUixLQUFLVSxJQUFJLENBQUNELGVBQWU7WUFFL0Isa0JBQWtCO1lBQ2xCLE1BQU1ULEtBQUtHLEtBQUssQ0FBQ1YsY0FBTSxDQUFDQyxTQUFTLENBQUM7WUFFbEMsMENBQTBDO1lBQzFDRixPQUFPakIsT0FBTzZCLG9CQUFvQixDQUNoQyxtQ0FDQTtnQkFDRU8sUUFBUTtnQkFDUkMsU0FBUztvQkFDUCxnQkFBZ0I7Z0JBQ2xCO2dCQUNBQyxNQUFNQyxLQUFLQyxTQUFTLENBQUM7b0JBQUUvQixVQUFVO2dCQUFVO1lBQzdDO1lBR0YsdURBQXVEO1lBQ3ZELE1BQU1lLElBQUFBLGVBQU8sRUFBQztnQkFDWlAsT0FBT2Ysa0JBQWtCMkIsb0JBQW9CLENBQUM7b0JBQzVDckIsSUFBSTtvQkFDSkMsVUFBVTtvQkFDVkMsWUFBWTtnQkFDZDtZQUNGO1FBQ0Y7UUFFQUMsS0FBSyx1REFBdUQ7WUFDMURYLE1BQU1xQixxQkFBcUIsQ0FBQztnQkFDMUJDLElBQUk7Z0JBQ0pDLE1BQU0sVUFBWWhCO1lBQ3BCO1lBRUEsTUFBTWtCLE9BQU9DLGtCQUFTLENBQUNDLEtBQUs7WUFDNUJiLElBQUFBLGNBQU0sZ0JBQUMscUJBQUNDLHFCQUFZO2dCQUFDQyxjQUFjZDs7WUFFbkMsTUFBTXNCLElBQUFBLGVBQU8sRUFBQztnQkFDWlAsT0FBT0MsY0FBTSxDQUFDQyxTQUFTLENBQUMseUJBQXlCQyxpQkFBaUI7WUFDcEU7WUFFQSxNQUFNSyxLQUFLRyxLQUFLLENBQUNWLGNBQU0sQ0FBQ0MsU0FBUyxDQUFDO1lBRWxDLE1BQU1zQixlQUFldkIsY0FBTSxDQUFDQyxTQUFTLENBQUM7WUFDdENGLE9BQU93QixjQUFjQyxZQUFZO1FBQ25DO1FBRUEvQixLQUFLLDhDQUE4QztZQUNqRFgsTUFDR3FCLHFCQUFxQixDQUFDO2dCQUNyQkMsSUFBSTtnQkFDSkMsTUFBTSxVQUFZaEI7WUFDcEIsR0FDQ2MscUJBQXFCLENBQUM7Z0JBQ3JCQyxJQUFJO2dCQUNKQyxNQUFNLFVBQWEsQ0FBQTt3QkFBRW9CLE9BQU87b0JBQTBCLENBQUE7WUFDeEQ7WUFFRixNQUFNbEIsT0FBT0Msa0JBQVMsQ0FBQ0MsS0FBSztZQUM1QmIsSUFBQUEsY0FBTSxnQkFBQyxxQkFBQ0MscUJBQVk7Z0JBQUNDLGNBQWNkOztZQUVuQyxNQUFNc0IsSUFBQUEsZUFBTyxFQUFDO2dCQUNaUCxPQUFPQyxjQUFNLENBQUNDLFNBQVMsQ0FBQyx5QkFBeUJDLGlCQUFpQjtZQUNwRTtZQUVBLE1BQU1LLEtBQUtHLEtBQUssQ0FBQ1YsY0FBTSxDQUFDQyxTQUFTLENBQUM7WUFFbEMsTUFBTWUsZ0JBQWdCaEIsY0FBTSxDQUFDZSxjQUFjLENBQUM7WUFDNUMsTUFBTVIsS0FBS1UsSUFBSSxDQUFDRCxlQUFlO1lBRS9CLE1BQU1ULEtBQUtHLEtBQUssQ0FBQ1YsY0FBTSxDQUFDQyxTQUFTLENBQUM7WUFFbEMsTUFBTUssSUFBQUEsZUFBTyxFQUFDO2dCQUNaUCxPQUFPQyxjQUFNLENBQUNDLFNBQVMsQ0FBQyw0QkFBNEJDLGlCQUFpQjtZQUN2RTtRQUNGO1FBRUFULEtBQUssb0RBQW9EO1lBQ3ZEWCxNQUFNcUIscUJBQXFCLENBQUM7Z0JBQzFCQyxJQUFJO2dCQUNKQyxNQUFNLFVBQVloQjtZQUNwQjtZQUVBLE1BQU1rQixPQUFPQyxrQkFBUyxDQUFDQyxLQUFLO1lBQzVCYixJQUFBQSxjQUFNLGdCQUFDLHFCQUFDQyxxQkFBWTtnQkFBQ0MsY0FBY2Q7O1lBRW5DLE1BQU1zQixJQUFBQSxlQUFPLEVBQUM7Z0JBQ1pQLE9BQU9DLGNBQU0sQ0FBQ0MsU0FBUyxDQUFDLHlCQUF5QkMsaUJBQWlCO1lBQ3BFO1lBRUEsTUFBTUssS0FBS0csS0FBSyxDQUFDVixjQUFNLENBQUNDLFNBQVMsQ0FBQztZQUVsQyxNQUFNZSxnQkFBZ0JoQixjQUFNLENBQUNlLGNBQWMsQ0FBQztZQUM1QyxNQUFNUixLQUFLVSxJQUFJLENBQUNELGVBQWU7WUFFL0IsTUFBTVQsS0FBS0csS0FBSyxDQUFDVixjQUFNLENBQUNDLFNBQVMsQ0FBQztZQUVsQyx3QkFBd0I7WUFDeEJGLE9BQU9DLGNBQU0sQ0FBQzBCLGdCQUFnQixDQUFDLGFBQWFaLEdBQUcsQ0FBQ1osaUJBQWlCO1lBQ2pFSCxPQUFPQyxjQUFNLENBQUNDLFNBQVMsQ0FBQyx5QkFBeUJDLGlCQUFpQjtRQUNwRTtJQUNGO0lBRUFuQixTQUFTLGtCQUFrQjtRQUN6QlUsS0FBSyxpREFBaUQ7WUFDcERYLE1BQU02QyxxQkFBcUIsQ0FBQyxJQUFJQyxNQUFNO1lBRXRDaEMsSUFBQUEsY0FBTSxnQkFBQyxxQkFBQ0MscUJBQVk7Z0JBQUNDLGNBQWNkOztZQUVuQyxNQUFNc0IsSUFBQUEsZUFBTyxFQUFDO2dCQUNaUCxPQUFPQyxjQUFNLENBQUNDLFNBQVMsQ0FBQyx5QkFBeUJDLGlCQUFpQjtZQUNwRTtRQUNGO1FBRUFULEtBQUssbURBQW1EO1lBQ3REWCxNQUFNcUIscUJBQXFCLENBQUM7Z0JBQzFCQyxJQUFJO2dCQUNKeUIsUUFBUTtZQUNWO1lBRUFqQyxJQUFBQSxjQUFNLGdCQUFDLHFCQUFDQyxxQkFBWTtnQkFBQ0MsY0FBY2Q7O1lBRW5DLE1BQU1zQixJQUFBQSxlQUFPLEVBQUM7Z0JBQ1pQLE9BQU9DLGNBQU0sQ0FBQ0MsU0FBUyxDQUFDLHlCQUF5QkMsaUJBQWlCO1lBQ3BFO1FBQ0Y7SUFDRjtJQUVBbkIsU0FBUyxpQkFBaUI7UUFDeEJVLEtBQUssNENBQTRDO1lBQy9DWCxNQUFNcUIscUJBQXFCLENBQUM7Z0JBQzFCQyxJQUFJO2dCQUNKQyxNQUFNLFVBQVloQjtZQUNwQjtZQUVBTyxJQUFBQSxjQUFNLGdCQUFDLHFCQUFDQyxxQkFBWTtnQkFBQ0MsY0FBY2Q7O1lBRW5DLE1BQU1zQixJQUFBQSxlQUFPLEVBQUM7Z0JBQ1pQLE9BQU9DLGNBQU0sQ0FBQ0MsU0FBUyxDQUFDLHlCQUF5QkMsaUJBQWlCO1lBQ3BFO1lBRUEsTUFBTUssT0FBT0Msa0JBQVMsQ0FBQ0MsS0FBSztZQUM1QixNQUFNRixLQUFLRyxLQUFLLENBQUNWLGNBQU0sQ0FBQ0MsU0FBUyxDQUFDO1lBRWxDLE1BQU1lLGdCQUFnQmhCLGNBQU0sQ0FBQ2UsY0FBYyxDQUFDO1lBQzVDaEIsT0FBT2lCLGVBQWVjLGVBQWUsQ0FBQyxNQUFNO1lBQzVDL0IsT0FBT2lCLGVBQWVjLGVBQWUsQ0FBQyxRQUFRO1FBQ2hEO1FBRUFyQyxLQUFLLGdDQUFnQztZQUNuQ1gsTUFBTXFCLHFCQUFxQixDQUFDO2dCQUMxQkMsSUFBSTtnQkFDSkMsTUFBTSxVQUFZaEI7WUFDcEI7WUFFQSxNQUFNa0IsT0FBT0Msa0JBQVMsQ0FBQ0MsS0FBSztZQUM1QmIsSUFBQUEsY0FBTSxnQkFBQyxxQkFBQ0MscUJBQVk7Z0JBQUNDLGNBQWNkOztZQUVuQyxNQUFNc0IsSUFBQUEsZUFBTyxFQUFDO2dCQUNaUCxPQUFPQyxjQUFNLENBQUNDLFNBQVMsQ0FBQyxjQUFjQyxpQkFBaUI7WUFDekQ7WUFFQSwyQkFBMkI7WUFDM0IsTUFBTUssS0FBS3dCLEdBQUc7WUFDZCxNQUFNQyxrQkFBa0JoQyxjQUFNLENBQUNDLFNBQVMsQ0FBQyxhQUFhZ0MsT0FBTyxDQUFDO1lBQzlEbEMsT0FBT2lDLGlCQUFpQkUsV0FBVztZQUVuQyw2QkFBNkI7WUFDN0IsTUFBTTNCLEtBQUs0QixRQUFRLENBQUM7WUFDcEJwQyxPQUFPZixrQkFBa0IyQixvQkFBb0IsQ0FBQ3RCLFNBQVMsQ0FBQyxFQUFFO1FBQzVEO0lBQ0Y7SUFFQU4sU0FBUyx3QkFBd0I7UUFDL0JVLEtBQUssNkNBQTZDO1lBQ2hEWCxNQUFNcUIscUJBQXFCLENBQUM7Z0JBQzFCQyxJQUFJO2dCQUNKQyxNQUFNLFVBQVksRUFBRTtZQUN0QjtZQUVBVCxJQUFBQSxjQUFNLGdCQUFDLHFCQUFDQyxxQkFBWTtnQkFBQ0MsY0FBY2Q7O1lBRW5DLE1BQU1zQixJQUFBQSxlQUFPLEVBQUM7Z0JBQ1pQLE9BQU9DLGNBQU0sQ0FBQ0MsU0FBUyxDQUFDLHlCQUF5QkMsaUJBQWlCO1lBQ3BFO1lBRUEsOENBQThDO1lBQzlDSCxPQUFPQyxjQUFNLENBQUNhLFdBQVcsQ0FBQyxzQkFBc0JDLEdBQUcsQ0FBQ1osaUJBQWlCO1lBRXJFLDhDQUE4QztZQUM5Q0gsT0FBT0MsY0FBTSxDQUFDQyxTQUFTLENBQUMsdUJBQXVCQyxpQkFBaUI7UUFDbEU7UUFFQVQsS0FBSyxrREFBa0Q7WUFDckRYLE1BQ0dxQixxQkFBcUIsQ0FBQztnQkFDckJDLElBQUk7Z0JBQ0pDLE1BQU0sVUFBWSxFQUFFO1lBQ3RCLEdBQ0NGLHFCQUFxQixDQUFDO2dCQUNyQkMsSUFBSTtnQkFDSkMsTUFBTSxVQUFhLENBQUE7d0JBQ2pCZixJQUFJO3dCQUNKQyxVQUFVO3dCQUNWQyxZQUFZO29CQUNkLENBQUE7WUFDRjtZQUVGLE1BQU1lLE9BQU9DLGtCQUFTLENBQUNDLEtBQUs7WUFDNUJiLElBQUFBLGNBQU0sZ0JBQUMscUJBQUNDLHFCQUFZO2dCQUFDQyxjQUFjZDs7WUFFbkMsTUFBTXNCLElBQUFBLGVBQU8sRUFBQztnQkFDWlAsT0FBT0MsY0FBTSxDQUFDQyxTQUFTLENBQUMseUJBQXlCQyxpQkFBaUI7WUFDcEU7WUFFQSxNQUFNSyxLQUFLRyxLQUFLLENBQUNWLGNBQU0sQ0FBQ0MsU0FBUyxDQUFDO1lBRWxDLE1BQU1lLGdCQUFnQmhCLGNBQU0sQ0FBQ2UsY0FBYyxDQUFDO1lBQzVDLE1BQU1SLEtBQUtVLElBQUksQ0FBQ0QsZUFBZTtZQUUvQixNQUFNVCxLQUFLRyxLQUFLLENBQUNWLGNBQU0sQ0FBQ0MsU0FBUyxDQUFDO1lBRWxDRixPQUFPakIsT0FBTzZCLG9CQUFvQixDQUNoQyxtQ0FDQVosT0FBT3FDLGdCQUFnQixDQUFDO2dCQUN0QmhCLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQztvQkFBRS9CLFVBQVU7Z0JBQTBCO1lBQzdEO1FBRUo7UUFFQUUsS0FBSyw4Q0FBOEM7WUFDakRYLE1BQ0dxQixxQkFBcUIsQ0FBQztnQkFDckJDLElBQUk7Z0JBQ0pDLE1BQU0sVUFBWSxFQUFFO1lBQ3RCLEdBQ0NGLHFCQUFxQixDQUFDO2dCQUNyQkMsSUFBSTtnQkFDSkMsTUFBTSxVQUFhLENBQUE7d0JBQ2pCZixJQUFJO3dCQUNKQyxVQUFVO3dCQUNWQyxZQUFZO29CQUNkLENBQUE7WUFDRjtZQUVGLE1BQU1lLE9BQU9DLGtCQUFTLENBQUNDLEtBQUs7WUFDNUJiLElBQUFBLGNBQU0sZ0JBQUMscUJBQUNDLHFCQUFZO2dCQUFDQyxjQUFjZDs7WUFFbkMsTUFBTXNCLElBQUFBLGVBQU8sRUFBQztnQkFDWlAsT0FBT0MsY0FBTSxDQUFDQyxTQUFTLENBQUMseUJBQXlCQyxpQkFBaUI7WUFDcEU7WUFFQSxNQUFNSyxLQUFLRyxLQUFLLENBQUNWLGNBQU0sQ0FBQ0MsU0FBUyxDQUFDO1lBRWxDLE1BQU1lLGdCQUFnQmhCLGNBQU0sQ0FBQ2UsY0FBYyxDQUFDO1lBQzVDLE1BQU1SLEtBQUtVLElBQUksQ0FBQ0QsZUFBZTtZQUUvQixNQUFNVCxLQUFLRyxLQUFLLENBQUNWLGNBQU0sQ0FBQ0MsU0FBUyxDQUFDO1lBRWxDRixPQUFPakIsT0FBTzZCLG9CQUFvQixDQUNoQyxtQ0FDQVosT0FBT3FDLGdCQUFnQixDQUFDO2dCQUN0QmhCLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQztvQkFBRS9CLFVBQVU7Z0JBQWM7WUFDakQ7UUFFSjtJQUNGO0lBRUFSLFNBQVMsNkJBQTZCO1FBQ3BDVSxLQUFLLDhDQUE4QztZQUNqRCxNQUFNNEMsY0FBY0MsUUFBUUMsR0FBRyxDQUFDQyxtQkFBbUI7WUFDbkRGLFFBQVFDLEdBQUcsQ0FBQ0MsbUJBQW1CLEdBQUc7WUFFbEMxRCxNQUFNcUIscUJBQXFCLENBQUM7Z0JBQzFCQyxJQUFJO2dCQUNKQyxNQUFNLFVBQVloQjtZQUNwQjtZQUVBTyxJQUFBQSxjQUFNLGdCQUFDLHFCQUFDQyxxQkFBWTtnQkFBQ0MsY0FBY2Q7O1lBRW5DLE1BQU1zQixJQUFBQSxlQUFPLEVBQUM7Z0JBQ1pQLE9BQU9qQixPQUFPNkIsb0JBQW9CLENBQUM7WUFDckM7WUFFQSwrQkFBK0I7WUFDL0IyQixRQUFRQyxHQUFHLENBQUNDLG1CQUFtQixHQUFHSDtRQUNwQztRQUVBNUMsS0FBSyxnRUFBZ0U7WUFDbkUsTUFBTTRDLGNBQWNDLFFBQVFDLEdBQUcsQ0FBQ0MsbUJBQW1CO1lBQ25ELE9BQU9GLFFBQVFDLEdBQUcsQ0FBQ0MsbUJBQW1CO1lBRXRDMUQsTUFBTXFCLHFCQUFxQixDQUFDO2dCQUMxQkMsSUFBSTtnQkFDSkMsTUFBTSxVQUFZaEI7WUFDcEI7WUFFQU8sSUFBQUEsY0FBTSxnQkFBQyxxQkFBQ0MscUJBQVk7Z0JBQUNDLGNBQWNkOztZQUVuQyxNQUFNc0IsSUFBQUEsZUFBTyxFQUFDO2dCQUNaUCxPQUFPakIsT0FBTzZCLG9CQUFvQixDQUFDO1lBQ3JDO1lBRUEsK0JBQStCO1lBQy9CMkIsUUFBUUMsR0FBRyxDQUFDQyxtQkFBbUIsR0FBR0g7UUFDcEM7SUFDRjtBQUNGIn0=